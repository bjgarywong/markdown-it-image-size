{"version":3,"file":"index.umd.js","sources":["../src/specialCharacters.ts","../src/parse-image-size.ts","../src/index.ts"],"sourcesContent":["/*\n * SPDX-FileCopyrightText: 2022 The HedgeDoc developers (see AUTHORS file)\n *\n * SPDX-License-Identifier: AGPL-3.0-only\n */\n\nexport enum SpecialCharacters {\n  EXCLAMATION_MARK = 0x21,\n  OPENING_BRACKET = 0x5b,\n  OPENING_PARENTHESIS = 0x28,\n  WHITESPACE = 0x20,\n  NEW_LINE = 0x0a,\n  EQUALS = 0x3d,\n  LOWER_CASE_X = 0x78,\n  NUMBER_ZERO = 0x30,\n  NUMBER_NINE = 0x39,\n  PERCENTAGE = 0x25\n}\n","/*\n * SPDX-FileCopyrightText: 2022 The HedgeDoc developers (see AUTHORS file)\n *\n * SPDX-License-Identifier: AGPL-3.0-only\n */\n\nimport { SpecialCharacters } from './specialCharacters.js'\n\nexport interface ParseImageSize {\n  position: number\n  width: string\n  height: string\n}\n\nexport interface ParseNextNumber {\n  position: number\n  value: string\n}\n\nfunction isCharacterADigit(code: number) {\n  return code >= SpecialCharacters.NUMBER_ZERO && code <= SpecialCharacters.NUMBER_NINE\n}\n\nfunction findNextNotNumberCharacter(startPosition: number, maximalPosition: number, content: string): number {\n  for (let position = startPosition; position < maximalPosition; position += 1) {\n    const code = content.charCodeAt(position)\n    if (!isCharacterADigit(code) && code !== SpecialCharacters.PERCENTAGE) {\n      return position\n    }\n  }\n\n  return maximalPosition\n}\n\nfunction parseNextNumber(content: string, startPosition: number, maximalPosition: number): ParseNextNumber {\n  const endCharacterIndex = findNextNotNumberCharacter(startPosition, maximalPosition, content)\n\n  return {\n    position: endCharacterIndex,\n    value: content.slice(startPosition, endCharacterIndex)\n  }\n}\n\n/*\n size must follow = without any white spaces as follows\n (1) =300x200\n (2) =300x\n (3) =x200\n*/\nconst checkImageSizeStart = (code: number): boolean => {\n  return (\n    code === SpecialCharacters.LOWER_CASE_X ||\n    (code >= SpecialCharacters.NUMBER_ZERO && code <= SpecialCharacters.NUMBER_NINE)\n  )\n}\n\nexport function parseImageSize(\n  imageSize: string,\n  startCharacterPosition: number,\n  maximalCharacterPosition: number\n): ParseImageSize | undefined {\n  if (startCharacterPosition >= maximalCharacterPosition) {\n    return\n  }\n\n  let currentCharacterPosition = startCharacterPosition\n\n  if (imageSize.charCodeAt(currentCharacterPosition) !== SpecialCharacters.EQUALS /* = */) {\n    return\n  }\n\n  currentCharacterPosition += 1\n\n  if (!checkImageSizeStart(imageSize.charCodeAt(currentCharacterPosition))) {\n    return\n  }\n\n  // parse width\n  const width = parseNextNumber(imageSize, currentCharacterPosition, maximalCharacterPosition)\n  currentCharacterPosition = width.position\n\n  // next charactor must be 'x'\n  const code = imageSize.charCodeAt(currentCharacterPosition)\n  if (code !== SpecialCharacters.LOWER_CASE_X /* x */) {\n    return\n  }\n  currentCharacterPosition += 1\n\n  // parse height\n  const height = parseNextNumber(imageSize, currentCharacterPosition, maximalCharacterPosition)\n  currentCharacterPosition = height.position\n\n  return {\n    width: width.value,\n    height: height.value,\n    position: currentCharacterPosition\n  }\n}\n","/*\n * SPDX-FileCopyrightText: 2022 The HedgeDoc developers (see AUTHORS file)\n *\n * SPDX-License-Identifier: AGPL-3.0-only\n */\n\nimport MarkdownIt, { PluginSimple } from 'markdown-it'\nimport { RuleInline } from 'markdown-it/lib/parser_inline.mjs'\nimport StateInline from 'markdown-it/lib/rules_inline/state_inline.mjs'\nimport { ParseImageSize, parseImageSize } from './parse-image-size.js'\nimport { SpecialCharacters } from './specialCharacters.js'\n\nconst checkForImageTagStart = (state: StateInline): boolean => {\n  return (\n    state.src.charCodeAt(state.pos) === SpecialCharacters.EXCLAMATION_MARK &&\n    state.src.charCodeAt(state.pos + 1) === SpecialCharacters.OPENING_BRACKET\n  )\n}\n\nconst skipWhiteSpaces = (startPosition: number, state: StateInline): number => {\n  let position = startPosition\n  while (position < state.posMax) {\n    const code = state.src.charCodeAt(position)\n    if (code !== SpecialCharacters.WHITESPACE && code !== SpecialCharacters.NEW_LINE) {\n      break\n    }\n    position += 1\n  }\n  return position\n}\n\nfunction createImageToken(\n  state: StateInline,\n  labelStartIndex: number,\n  labelEndIndex: number,\n  href: string,\n  title: string,\n  width: string,\n  height: string\n) {\n  state.pos = labelStartIndex\n  state.posMax = labelEndIndex\n\n  const token = state.push('image', 'img', 0)\n  token.children = []\n\n  const newState = new state.md.inline.State(\n    state.src.slice(labelStartIndex, labelEndIndex),\n    state.md,\n    state.env,\n    token.children\n  )\n  newState.md.inline.tokenize(newState)\n\n  token.attrSet('src', href)\n  token.attrSet('alt', '')\n\n  if (title) {\n    token.attrSet('title', title)\n  }\n\n  if (width !== '') {\n    token.attrSet('width', width)\n  }\n\n  if (height !== '') {\n    token.attrSet('height', height)\n  }\n}\n\nfunction parseSizeParameters(startPosition: number, state: StateInline): ParseImageSize | undefined {\n  // [link](  <href>  \"title\" =WxH  )\n  //                          ^^^^ parsing image size\n  if (startPosition - 1 < 0) {\n    return\n  }\n  const code = state.src.charCodeAt(startPosition - 1)\n  if (code !== SpecialCharacters.WHITESPACE) {\n    return\n  }\n  const res = parseImageSize(state.src, startPosition, state.posMax)\n  if (!res) {\n    return\n  }\n\n  // [link](  <href>  \"title\" =WxH  )\n  //                              ^^ skipping these spaces\n  return {\n    position: skipWhiteSpaces(res.position, state),\n    width: res.width,\n    height: res.height\n  }\n}\n\nexport interface ParseLinkResult {\n  position: number\n  href: string\n}\n\n// [link](  <href>  \"title\"  )\n//          ^^^^^^ parsing link destination\nfunction parseLink(state: StateInline, startPosition: number): ParseLinkResult | undefined {\n  const linkParseResult = state.md.helpers.parseLinkDestination(state.src, startPosition, state.posMax)\n  if (!linkParseResult.ok) {\n    return\n  }\n  const href = state.md.normalizeLink(linkParseResult.str)\n  if (state.md.validateLink(href)) {\n    return { position: linkParseResult.pos, href }\n  } else {\n    return { position: startPosition, href: '' }\n  }\n}\n\nconst imageWithSize: RuleInline = (state: any, silent: any) => {\n  let position,\n    title,\n    start,\n    href = '',\n    width = '',\n    height = ''\n  const oldPos = state.pos,\n    max = state.posMax\n\n  if (!checkForImageTagStart(state)) {\n    return false\n  }\n\n  const labelStartIndex = state.pos + 2\n  const labelEndIndex = state.md.helpers.parseLinkLabel(state, state.pos + 1, false)\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEndIndex < 0) {\n    return false\n  }\n\n  position = labelEndIndex + 1\n  if (position < max && state.src.charCodeAt(position) === SpecialCharacters.OPENING_PARENTHESIS) {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    position += 1\n    position = skipWhiteSpaces(position, state)\n    if (position >= max) {\n      return false\n    }\n\n    const parseLinkResult = parseLink(state, position)\n    if (!parseLinkResult) {\n      return false\n    }\n    position = parseLinkResult.position\n    href = parseLinkResult.href\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    start = position\n    position = skipWhiteSpaces(position, state)\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    const parseLinkTitleResult = state.md.helpers.parseLinkTitle(state.src, position, state.posMax)\n    if (position < max && start !== position && parseLinkTitleResult.ok) {\n      title = parseLinkTitleResult.str\n      position = parseLinkTitleResult.pos\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      position = skipWhiteSpaces(position, state)\n    } else {\n      title = ''\n    }\n\n    const parseSizeParametersResult = parseSizeParameters(position, state)\n    if (parseSizeParametersResult) {\n      position = parseSizeParametersResult.position\n      width = parseSizeParametersResult.width\n      height = parseSizeParametersResult.height\n    }\n\n    if (position >= max || state.src.charCodeAt(position) !== 0x29 /* ) */) {\n      state.pos = oldPos\n      return false\n    }\n    position += 1\n  } else {\n    //\n    // Link reference\n    //\n    if (typeof state.env.references === 'undefined') {\n      return false\n    }\n\n    // [foo]  [bar]\n    //      ^^ optional whitespace (can include newlines)\n    position = skipWhiteSpaces(position, state)\n\n    let label\n\n    if (position < max && state.src.charCodeAt(position) === 0x5b /* [ */) {\n      start = position + 1\n      position = state.md.helpers.parseLinkLabel(state, position)\n      if (position >= 0) {\n        label = state.src.slice(start, (position += 1))\n      } else {\n        position = labelEndIndex + 1\n      }\n    } else {\n      position = labelEndIndex + 1\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) {\n      label = state.src.slice(labelStartIndex, labelEndIndex)\n    }\n\n    const ref = state.env.references[state.md.utils.normalizeReference(label)]\n    if (!ref) {\n      state.pos = oldPos\n      return false\n    }\n    href = ref.href\n    title = ref.title\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    if (width == '' && height == '') {\n      width = '100%'\n    }\n    createImageToken(state, labelStartIndex, labelEndIndex, href, title, width, height)\n  }\n\n  state.pos = position\n  state.posMax = max\n  return true\n}\n\nexport const imageSize: PluginSimple = (md: MarkdownIt) => {\n  md.inline.ruler.before('emphasis', 'image', imageWithSize as any)\n}\n"],"names":["SpecialCharacters","isCharacterADigit","code","NUMBER_ZERO","NUMBER_NINE","parseNextNumber","content","startPosition","maximalPosition","endCharacterIndex","position","charCodeAt","PERCENTAGE","findNextNotNumberCharacter","value","slice","skipWhiteSpaces","state","posMax","src","WHITESPACE","NEW_LINE","imageWithSize","silent","title","start","href","width","height","oldPos","pos","max","EXCLAMATION_MARK","OPENING_BRACKET","checkForImageTagStart","labelStartIndex","labelEndIndex","md","helpers","parseLinkLabel","OPENING_PARENTHESIS","parseLinkResult","linkParseResult","parseLinkDestination","ok","normalizeLink","str","validateLink","parseLink","parseLinkTitleResult","parseLinkTitle","parseSizeParametersResult","res","imageSize","startCharacterPosition","maximalCharacterPosition","currentCharacterPosition","EQUALS","LOWER_CASE_X","parseImageSize","parseSizeParameters","env","references","label","ref","utils","normalizeReference","token","push","children","newState","inline","State","tokenize","attrSet","createImageToken","ruler","before"],"mappings":"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"}