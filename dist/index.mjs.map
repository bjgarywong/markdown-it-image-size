{"version":3,"file":"index.mjs","sources":["../src/specialCharacters.ts","../src/parse-image-size.ts","../src/options.ts","../src/index.ts"],"sourcesContent":["/*\n * SPDX-FileCopyrightText: 2022 The HedgeDoc developers (see AUTHORS file)\n *\n * SPDX-License-Identifier: AGPL-3.0-only\n */\n\nexport enum SpecialCharacters {\n  EXCLAMATION_MARK = 0x21,\n  OPENING_BRACKET = 0x5b,\n  OPENING_PARENTHESIS = 0x28,\n  WHITESPACE = 0x20,\n  NEW_LINE = 0x0a,\n  EQUALS = 0x3d,\n  LOWER_CASE_X = 0x78,\n  NUMBER_ZERO = 0x30,\n  NUMBER_NINE = 0x39,\n  PERCENTAGE = 0x25\n}\n","/*\n * SPDX-FileCopyrightText: 2022 The HedgeDoc developers (see AUTHORS file)\n *\n * SPDX-License-Identifier: AGPL-3.0-only\n */\n\nimport { SpecialCharacters } from './specialCharacters.js'\n\nexport interface ParseImageSize {\n  position: number\n  width: string\n  height: string\n}\n\nexport interface ParseNextNumber {\n  position: number\n  value: string\n}\n\nfunction isCharacterADigit(code: number) {\n  return code >= SpecialCharacters.NUMBER_ZERO && code <= SpecialCharacters.NUMBER_NINE\n}\n\nfunction findNextNotNumberCharacter(startPosition: number, maximalPosition: number, content: string): number {\n  for (let position = startPosition; position < maximalPosition; position += 1) {\n    const code = content.charCodeAt(position)\n    if (!isCharacterADigit(code) && code !== SpecialCharacters.PERCENTAGE) {\n      return position\n    }\n  }\n\n  return maximalPosition\n}\n\nfunction parseNextNumber(content: string, startPosition: number, maximalPosition: number): ParseNextNumber {\n  const endCharacterIndex = findNextNotNumberCharacter(startPosition, maximalPosition, content)\n\n  return {\n    position: endCharacterIndex,\n    value: content.slice(startPosition, endCharacterIndex)\n  }\n}\n\n/*\n size must follow = without any white spaces as follows\n (1) =300x200\n (2) =300x\n (3) =x200\n*/\nconst checkImageSizeStart = (code: number): boolean => {\n  return (\n    code === SpecialCharacters.LOWER_CASE_X ||\n    (code >= SpecialCharacters.NUMBER_ZERO && code <= SpecialCharacters.NUMBER_NINE)\n  )\n}\n\nexport function parseImageSize(\n  imageSize: string,\n  startCharacterPosition: number,\n  maximalCharacterPosition: number\n): ParseImageSize | undefined {\n  if (startCharacterPosition >= maximalCharacterPosition) {\n    return\n  }\n\n  let currentCharacterPosition = startCharacterPosition\n\n  if (imageSize.charCodeAt(currentCharacterPosition) !== SpecialCharacters.EQUALS /* = */) {\n    return\n  }\n\n  currentCharacterPosition += 1\n\n  if (!checkImageSizeStart(imageSize.charCodeAt(currentCharacterPosition))) {\n    return\n  }\n\n  // parse width\n  const width = parseNextNumber(imageSize, currentCharacterPosition, maximalCharacterPosition)\n  currentCharacterPosition = width.position\n\n  // next charactor must be 'x'\n  const code = imageSize.charCodeAt(currentCharacterPosition)\n  if (code !== SpecialCharacters.LOWER_CASE_X /* x */) {\n    return\n  }\n  currentCharacterPosition += 1\n\n  // parse height\n  const height = parseNextNumber(imageSize, currentCharacterPosition, maximalCharacterPosition)\n  currentCharacterPosition = height.position\n\n  return {\n    width: width.value,\n    height: height.value,\n    position: currentCharacterPosition\n  }\n}\n","import { Options, Token } from 'markdown-it'\n\ninterface ImSizeOptions {\n  defaultWidth?: string\n  customRender?: boolean\n}\n\nconst customRender = (tokens: Token[], idx: number, options: Options, env: any, slf: any) => {\n  const token = tokens[idx]!\n  const attrs = token.attrs!\n  attrs[token.attrIndex('alt')][1] = slf.renderInlineAsText(token.children!, options, env);\n  let result = slf.renderToken(tokens, idx, options);\n  if (! attrs.find((attr) => attr[0] == 'width' || attr[0] == 'height')) {\n    if (result.endsWith(\"/>\")) {\n      result = result.slice(0, -2) + ' style=\"max-width:100%\"/>'\n    }\n    else if (result.endsWith(\">\")) {\n      result = result.slice(0, -1) + ' style=\"max-width:100%\">'\n    }\n  }\n  return result\n}\n\nexport {\n  ImSizeOptions,\n  customRender\n}\n","/*\n * SPDX-FileCopyrightText: 2022 The HedgeDoc developers (see AUTHORS file)\n *\n * SPDX-License-Identifier: AGPL-3.0-only\n */\n\nimport MarkdownIt, { PluginSimple, PluginWithOptions } from 'markdown-it'\nimport { RuleInline } from 'markdown-it/lib/parser_inline.mjs'\nimport StateInline from 'markdown-it/lib/rules_inline/state_inline.mjs'\nimport { ParseImageSize, parseImageSize } from './parse-image-size.js'\nimport { SpecialCharacters } from './specialCharacters.js'\nimport { ImSizeOptions, customRender } from './options.js'\n\nconst checkForImageTagStart = (state: StateInline): boolean => {\n  return (\n    state.src.charCodeAt(state.pos) === SpecialCharacters.EXCLAMATION_MARK &&\n    state.src.charCodeAt(state.pos + 1) === SpecialCharacters.OPENING_BRACKET\n  )\n}\n\nconst skipWhiteSpaces = (startPosition: number, state: StateInline): number => {\n  let position = startPosition\n  while (position < state.posMax) {\n    const code = state.src.charCodeAt(position)\n    if (code !== SpecialCharacters.WHITESPACE && code !== SpecialCharacters.NEW_LINE) {\n      break\n    }\n    position += 1\n  }\n  return position\n}\n\nfunction createImageToken(\n  state: StateInline,\n  labelStartIndex: number,\n  labelEndIndex: number,\n  href: string,\n  title: string,\n  width: string,\n  height: string\n) {\n  state.pos = labelStartIndex\n  state.posMax = labelEndIndex\n\n  const token = state.push('image', 'img', 0)\n  token.children = []\n\n  const newState = new state.md.inline.State(\n    state.src.slice(labelStartIndex, labelEndIndex),\n    state.md,\n    state.env,\n    token.children\n  )\n  newState.md.inline.tokenize(newState)\n\n  token.attrSet('src', href)\n  token.attrSet('alt', '')\n\n  if (title) {\n    token.attrSet('title', title)\n  }\n\n  if (width !== '') {\n    token.attrSet('width', width)\n  }\n\n  if (height !== '') {\n    token.attrSet('height', height)\n  }\n}\n\nfunction parseSizeParameters(startPosition: number, state: StateInline): ParseImageSize | undefined {\n  // [link](  <href>  \"title\" =WxH  )\n  //                          ^^^^ parsing image size\n  if (startPosition - 1 < 0) {\n    return\n  }\n  const code = state.src.charCodeAt(startPosition - 1)\n  if (code !== SpecialCharacters.WHITESPACE) {\n    return\n  }\n  const res = parseImageSize(state.src, startPosition, state.posMax)\n  if (!res) {\n    return\n  }\n\n  // [link](  <href>  \"title\" =WxH  )\n  //                              ^^ skipping these spaces\n  return {\n    position: skipWhiteSpaces(res.position, state),\n    width: res.width,\n    height: res.height\n  }\n}\n\nexport interface ParseLinkResult {\n  position: number\n  href: string\n}\n\n// [link](  <href>  \"title\"  )\n//          ^^^^^^ parsing link destination\nfunction parseLink(state: StateInline, startPosition: number): ParseLinkResult | undefined {\n  const linkParseResult = state.md.helpers.parseLinkDestination(state.src, startPosition, state.posMax)\n  if (!linkParseResult.ok) {\n    return\n  }\n  const href = state.md.normalizeLink(linkParseResult.str)\n  if (state.md.validateLink(href)) {\n    return { position: linkParseResult.pos, href }\n  } else {\n    return { position: startPosition, href: '' }\n  }\n}\n\nconst imageWithSize: RuleInline = (state: any, silent: any) => {\n  let position,\n    title,\n    start,\n    href = '',\n    width = '',\n    height = ''\n  const oldPos = state.pos,\n    max = state.posMax\n\n  if (!checkForImageTagStart(state)) {\n    return false\n  }\n\n  const labelStartIndex = state.pos + 2\n  const labelEndIndex = state.md.helpers.parseLinkLabel(state, state.pos + 1, false)\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEndIndex < 0) {\n    return false\n  }\n\n  position = labelEndIndex + 1\n  if (position < max && state.src.charCodeAt(position) === SpecialCharacters.OPENING_PARENTHESIS) {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    position += 1\n    position = skipWhiteSpaces(position, state)\n    if (position >= max) {\n      return false\n    }\n\n    const parseLinkResult = parseLink(state, position)\n    if (!parseLinkResult) {\n      return false\n    }\n    position = parseLinkResult.position\n    href = parseLinkResult.href\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    start = position\n    position = skipWhiteSpaces(position, state)\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    const parseLinkTitleResult = state.md.helpers.parseLinkTitle(state.src, position, state.posMax)\n    if (position < max && start !== position && parseLinkTitleResult.ok) {\n      title = parseLinkTitleResult.str\n      position = parseLinkTitleResult.pos\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      position = skipWhiteSpaces(position, state)\n    } else {\n      title = ''\n    }\n\n    const parseSizeParametersResult = parseSizeParameters(position, state)\n    if (parseSizeParametersResult) {\n      position = parseSizeParametersResult.position\n      width = parseSizeParametersResult.width\n      height = parseSizeParametersResult.height\n    }\n\n    if (position >= max || state.src.charCodeAt(position) !== 0x29 /* ) */) {\n      state.pos = oldPos\n      return false\n    }\n    position += 1\n  } else {\n    //\n    // Link reference\n    //\n    if (typeof state.env.references === 'undefined') {\n      return false\n    }\n\n    // [foo]  [bar]\n    //      ^^ optional whitespace (can include newlines)\n    position = skipWhiteSpaces(position, state)\n\n    let label\n\n    if (position < max && state.src.charCodeAt(position) === 0x5b /* [ */) {\n      start = position + 1\n      position = state.md.helpers.parseLinkLabel(state, position)\n      if (position >= 0) {\n        label = state.src.slice(start, (position += 1))\n      } else {\n        position = labelEndIndex + 1\n      }\n    } else {\n      position = labelEndIndex + 1\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) {\n      label = state.src.slice(labelStartIndex, labelEndIndex)\n    }\n\n    const ref = state.env.references[state.md.utils.normalizeReference(label)]\n    if (!ref) {\n      state.pos = oldPos\n      return false\n    }\n    href = ref.href\n    title = ref.title\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    if (width == '' && height == '' && !(imageWithSize as any).customRender) {      \n      const defaultWidth: string = (imageWithSize as any).defaultWidth\n      if (defaultWidth !== undefined) {\n        width = defaultWidth\n      }\n    }\n    createImageToken(state, labelStartIndex, labelEndIndex, href, title, width, height)\n  }\n\n  state.pos = position\n  state.posMax = max\n  return true\n}\n\nexport const imageSize: PluginWithOptions = (md: MarkdownIt, options?: ImSizeOptions) => {\n  if (options !== undefined) {\n    if (options.defaultWidth) {\n      (imageWithSize as any).defaultWidth = options.defaultWidth\n    }\n    if (options.customRender) {\n      (imageWithSize as any).customRender = options.customRender\n      md.renderer.rules.image = customRender\n    }\n  }\n  md.inline.ruler.before('emphasis', 'image', imageWithSize as any)\n}\n"],"names":["SpecialCharacters","isCharacterADigit","code","NUMBER_ZERO","NUMBER_NINE","parseNextNumber","content","startPosition","maximalPosition","endCharacterIndex","position","charCodeAt","PERCENTAGE","findNextNotNumberCharacter","value","slice","customRender","tokens","idx","options","env","slf","token","attrs","attrIndex","renderInlineAsText","children","result","renderToken","find","attr","endsWith","skipWhiteSpaces","state","posMax","src","WHITESPACE","NEW_LINE","imageWithSize","silent","title","start","href","width","height","oldPos","pos","max","EXCLAMATION_MARK","OPENING_BRACKET","checkForImageTagStart","labelStartIndex","labelEndIndex","md","helpers","parseLinkLabel","OPENING_PARENTHESIS","parseLinkResult","linkParseResult","parseLinkDestination","ok","normalizeLink","str","validateLink","parseLink","parseLinkTitleResult","parseLinkTitle","parseSizeParametersResult","res","imageSize","startCharacterPosition","maximalCharacterPosition","currentCharacterPosition","EQUALS","LOWER_CASE_X","parseImageSize","parseSizeParameters","references","label","ref","utils","normalizeReference","defaultWidth","undefined","push","newState","inline","State","tokenize","attrSet","createImageToken","renderer","rules","image","ruler","before"],"mappings":"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"}